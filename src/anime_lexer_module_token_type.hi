#ifndef ANIME_TOKEN_TYPE_H
#define ANIME_TOKEN_TYPE_H

// RL: All those tokens should be ordered by priorities: 
//     the lowest priority first, the highest priority last. 

#define ANIME__TOKEN_TYPE__LIST						\
  X(ANIME_TOKEN_NULL,) /* It's the invalid token. */			\
    X(ANIME_TOKEN_EOF,)							\
    /* RL: Syntatic sugar */ /* Very low priority, i.e. outmost nodes  */ \
    X(ANIME_TOKEN_OF,)							\
    X(ANIME_TOKEN_TO,)							\
    X(ANIME_TOKEN_DOWNTO,)						\
    X(ANIME_TOKEN_STEP,)						\
    X(ANIME_TOKEN_PTVIRG,)						\
    X(ANIME_TOKEN_OPENPAR,)						\
    X(ANIME_TOKEN_CLOSEPAR,)						\
    X(ANIME_TOKEN_OPENBRACKET,)						\
    X(ANIME_TOKEN_CLOSEBRACKET,)					\
    X(ANIME_TOKEN_OPENBRACE,)						\
    X(ANIME_TOKEN_CLOSEBRACE,)						\
    X(ANIME_TOKEN_DEUXPOINTS,)						\
  X(ANIME_TOKEN_VIRGULE,)						\
  X(ANIME_TOKEN_AS,)							\
  X(ANIME_TOKEN_HUH,)							\
  /* RL: EXPR */							\
  X(ANIME_TOKEN_AFFECTATION,)						\
  X(ANIME_TOKEN_AFFECTATION_SIMPLE,)					\
  X(ANIME_TOKEN_AFFECTATION_IADD,)					\
  X(ANIME_TOKEN_AFFECTATION_RADD,)					\
  X(ANIME_TOKEN_AFFECTATION_ISUB,)					\
  X(ANIME_TOKEN_AFFECTATION_RSUB,)					\
  X(ANIME_TOKEN_AFFECTATION_IMULT,)					\
  X(ANIME_TOKEN_AFFECTATION_RMULT,)					\
  X(ANIME_TOKEN_AFFECTATION_IDIV,)					\
  X(ANIME_TOKEN_AFFECTATION_RDIV,)					\
  X(ANIME_TOKEN_AFFECTATION_IMOD,)					\
  X(ANIME_TOKEN_AFFECTATION_L_AND,)					\
    X(ANIME_TOKEN_AFFECTATION_L_OR,)					\
    X(ANIME_TOKEN_AFFECTATION_L_XOR,)					\
    X(ANIME_TOKEN_AFFECTATION_L_NOT,)					\
    X(ANIME_TOKEN_AFFECTATION_B_AND,)					\
    X(ANIME_TOKEN_AFFECTATION_B_OR,)					\
    X(ANIME_TOKEN_AFFECTATION_B_XOR,)					\
    X(ANIME_TOKEN_AFFECTATION_B_NOT,)					\
    X(ANIME_TOKEN_AFFECTATION_B_RSHIFT,)				\
    X(ANIME_TOKEN_AFFECTATION_B_LSHIFT,)				\
    X(ANIME_TOKEN_LOGICAL_AND,)						\
    X(ANIME_TOKEN_LOGICAL_OR,)						\
  X(ANIME_TOKEN_LOGICAL_XOR,) /* RL: BITWISE_XOR is definitely different. */ \
  X(ANIME_TOKEN_LOGICAL_NOT,)						\
  X(ANIME_TOKEN_EQUAL,) /* RL: The question is the interpretation of "a == b and d != e". */ \
  X(ANIME_TOKEN_DIFF,)							\
  X(ANIME_TOKEN_INF,) /* RL: The question is the interpretation of "a < b and d >= e". */ \
  X(ANIME_TOKEN_SUP,)							\
  X(ANIME_TOKEN_INFEQ,)							\
    X(ANIME_TOKEN_SUPEQ,)						\
  X(ANIME_TOKEN_IDIV,) /* RL: This thing has definitely a low priority: "1 + 2 div 4 + 3" */ \
  X(ANIME_TOKEN_IMOD,)							\
  X(ANIME_TOKEN_BITWISE_AND,)						\
    X(ANIME_TOKEN_BITWISE_OR,)						\
  X(ANIME_TOKEN_BITWISE_XOR,) /* RL: BOOL_XOR is definitely different. */ \
  X(ANIME_TOKEN_BITWISE_NOT,)						\
  X(ANIME_TOKEN_BITWISE_SHIFT_LEFT,)					\
  X(ANIME_TOKEN_BITWISE_SHIFT_RIGHT,)					\
  X(ANIME_TOKEN_IPLUS,)							\
  X(ANIME_TOKEN_RPLUS,)							\
  X(ANIME_TOKEN_IMOINS,)						\
    X(ANIME_TOKEN_RMOINS,)						\
    X(ANIME_TOKEN_IPLUS_BINAIRE,)					\
    X(ANIME_TOKEN_RPLUS_BINAIRE,)					\
    X(ANIME_TOKEN_IMOINS_BINAIRE,)					\
    X(ANIME_TOKEN_RMOINS_BINAIRE,)					\
    X(ANIME_TOKEN_IMULT,)						\
    X(ANIME_TOKEN_RMULT,)						\
    X(ANIME_TOKEN_RDIV,)						\
    X(ANIME_TOKEN_POINT,)						\
    X(ANIME_TOKEN_FLECHE,)						\
    X(ANIME_TOKEN_PTR,)							\
    X(ANIME_TOKEN_REF,)							\
    X(ANIME_TOKEN_IPLUS_UNAIRE,)					\
    X(ANIME_TOKEN_RPLUS_UNAIRE,)					\
    X(ANIME_TOKEN_IMOINS_UNAIRE,)					\
  X(ANIME_TOKEN_RMOINS_UNAIRE,)						\
  X(ANIME_TOKEN_INC,)							\
  X(ANIME_TOKEN_DEC,)							\
  /* RL: Constant values, which have the upmost priorities */		\
  X(ANIME_TOKEN_TRUE,)							\
  X(ANIME_TOKEN_FALSE,)							\
  X(ANIME_TOKEN_ENTIER,)						\
    X(ANIME_TOKEN_REEL__VIRG,)						\
  X(ANIME_TOKEN_REEL__DOT,)						\
  X(ANIME_TOKEN_REEL__E,)						\
    X(ANIME_TOKEN_STRING_C,)						\
  X(ANIME_TOKEN_STRING_C__EOL,)						\
  X(ANIME_TOKEN_STRING_C__EOF,)						\
  X(ANIME_TOKEN_STRING_P,)						\
  X(ANIME_TOKEN_STRING_P__EOL,)						\
  X(ANIME_TOKEN_STRING_P__EOF,)						\
  X(ANIME_TOKEN_NIL,)							\
  X(ANIME_TOKEN_NULL_PTR,)						\
  /* RL: LL(1) type */							\
  X(ANIME_TOKEN_TYPE,)							\
  X(ANIME_TOKEN_TYPE_ALIAS,)						\
    X(ANIME_TOKEN_BOOLEAN,)						\
    X(ANIME_TOKEN_INTEGER,)						\
    X(ANIME_TOKEN_FLOAT,)						\
    X(ANIME_TOKEN_STRING,)						\
    X(ANIME_TOKEN_SUBRANGE,)						\
    X(ANIME_TOKEN_ARRAY,)						\
    X(ANIME_TOKEN_RECORD,)						\
    X(ANIME_TOKEN_VARIANT,)						\
    /* RL: LL(1) control flow */					\
    X(ANIME_TOKEN_IF,)							\
    X(ANIME_TOKEN_WHEN,)						\
    X(ANIME_TOKEN_UNLESS,)						\
    X(ANIME_TOKEN_WHILE,)						\
    X(ANIME_TOKEN_FOR,)							\
    X(ANIME_TOKEN_REPEAT,)						\
  X(ANIME_TOKEN_BEGIN,)							\
  X(ANIME_TOKEN_PROCEDURE,)						\
  X(ANIME_TOKEN_FONCTION,)						\
  X(ANIME_TOKEN_METHODE,)						\
  X(ANIME_TOKEN_LAMBDA,)						\
  X(ANIME_TOKEN_CONST,)							\
  X(ANIME_TOKEN_VAR,)							\
    /*ANIME_TOKEN_REC, // RL: Needless. 'This' is not a token as well. */ \
    /* RL: control flow others */					\
    X(ANIME_TOKEN_DONE,)						\
  X(ANIME_TOKEN_DO,)							\
  X(ANIME_TOKEN_THEN,)							\
    X(ANIME_TOKEN_ELSE,)						\
  X(ANIME_TOKEN_FI,)							\
  X(ANIME_TOKEN_UNTIL,)							\
  X(ANIME_TOKEN_END,)							\
    /* RL: Other qualifying keywords */					\
  X(ANIME_TOKEN_BYREF,)							\
  X(ANIME_TOKEN_BYVAL,)							\
  /* RL: Ident */							\
  X(ANIME_TOKEN_SYNTAX_MASTER,)						\
  X(ANIME_TOKEN_SYNTAX_KEYWORD,) /* RL: Could be handled like a regular ident by the parser? */ \
  X(ANIME_TOKEN_IDENT,)							\
  /* RL: Ignored tokens */						\
  X(ANIME_TOKEN_EOL,)							\
  X(ANIME_TOKEN_BLANC,)							\
    X(ANIME_TOKEN_COMMENT__ONE_LINE_CPP,)				\
    X(ANIME_TOKEN_COMMENT__ONE_LINE_SCRIPT,)				\
    X(ANIME_TOKEN_COMMENT__MULTI_LINES_C_STYLE,)			\
    X(ANIME_TOKEN_COMMENT__MULTI_LINES_C_STYLE__EOF,)			\
    X(ANIME_TOKEN_COMMENT__MULTI_LINES_C_STYLE__LONELY_ENDING,)		\
    X(ANIME_TOKEN_TYPE_COUNT,)						\
    /* LAST_LINE*/


#define ANIME__TOKEN_TYPE__H
#define ANIME__TOKEN_TYPE__TYPE_T uint8_t 
#define EXTERN extern
#include "anime_lexer_module_token_type.ci"
#undef  EXTERN
#undef  ANIME__TOKEN_TYPE__TYPE_T
#undef  ANIME__TOKEN_TYPE__H

enum { ANIME_TOKEN__SYNTAX_MASTER__BASE  = ANIME_TOKEN_TYPE_COUNT }; 
enum { ANIME_TOKEN__SYNTAX_MASTER__SIZE  = 16 }; 
enum { ANIME_TOKEN__SYNTAX_MASTER__TOP   = ANIME_TOKEN__SYNTAX_MASTER__BASE + ANIME_TOKEN__SYNTAX_MASTER__SIZE }; 

enum { ANIME_TOKEN__SYNTAX_KEYWORD__BASE = ANIME_TOKEN__SYNTAX_MASTER__TOP }; 
enum { ANIME_TOKEN__SYNTAX_KEYWORD__SIZE = 16 }; 
enum { ANIME_TOKEN__SYNTAX_KEYWORD__TOP  = ANIME_TOKEN__SYNTAX_KEYWORD__BASE + ANIME_TOKEN__SYNTAX_KEYWORD__SIZE }; 

//#define TOKEN_MAX ANIME_TOKEN_COUNT 
enum { TOKEN_MAX = ANIME_TOKEN__SYNTAX_KEYWORD__TOP }; 



 
// RL: Token aliases. 
enum { 
  ANIME_TOKEN_TYPE_INVALID  = ANIME_TOKEN_NULL, 
  ANIME_TOKEN_ASSIGN        = ANIME_TOKEN_AFFECTATION, 
  ANIME_TOKEN_METHOD        = ANIME_TOKEN_METHODE, 
  ANIME_TOKEN_COMMA         = ANIME_TOKEN_VIRGULE, 
  ANIME_TOKEN_COLON         = ANIME_TOKEN_DEUXPOINTS, 
  ANIME_TOKEN_SEMICOLON     = ANIME_TOKEN_PTVIRG, 
  ANIME_TOKEN_POINTVIRGULE  = ANIME_TOKEN_PTVIRG, 
  ANIME_TOKEN_POINT_VIRGULE = ANIME_TOKEN_PTVIRG, 
  ANIME_TOKEN_FUNCTION      = ANIME_TOKEN_FONCTION, 
  ANIME_TOKEN_IMINUS        = ANIME_TOKEN_IMOINS, 
  ANIME_TOKEN_RMINUS        = ANIME_TOKEN_RMOINS, 
  ANIME_TOKEN_DOT           = ANIME_TOKEN_POINT, 
  ANIME_TOKEN_ARROW         = ANIME_TOKEN_FLECHE, 
  ANIME_TOKEN_CHAINE_C      = ANIME_TOKEN_STRING_C, 
  ANIME_TOKEN_CHAINE_P      = ANIME_TOKEN_STRING_P, 
  ANIME_TOKEN_REAL          = ANIME_TOKEN_FLOAT, 
}; 

typedef       uint8_t                 int_anime_token_type_t; 
extern  const int_anime_token_type_t  int_anime_token_type_max; // RL: Use for storage, where data should be packed. Anywhere else, 'int' is good. The property ensures that a token_type will fit into a 'int_anime_token_type_t'. 

extern const int_anime_token_type_t anime_token_type_count; 

extern const char * anime_token__type_get_cstr(const int_anime_token_type_t token_type); 
#define anime_token__type_cstr anime_token__type_get_cstr

#define anime_token__type_get_cstr int_anime_token_type__get_cstr

static void int_anime_token_type__check_and_assert(void); 





#define CONSTANT_VALUE_HUH(token_type) (int_member_huh((token_type), ANIME_TOKEN_TRUE, ANIME_TOKEN_FALSE, ANIME_TOKEN_ENTIER, ANIME_TOKEN_REEL__VIRG, ANIME_TOKEN_REEL__DOT, ANIME_TOKEN_REEL__E, ANIME_TOKEN_CHAINE_C, ANIME_TOKEN_CHAINE_P, ANIME_TOKEN_NIL, ANIME_TOKEN_NULL_PTR, ANIME_TOKEN_IDENT))

#define UNARY_PREFIX_OPERATOR_HUH(token_type) (int_member_huh((token_type), ANIME_TOKEN_LOGICAL_NOT, ANIME_TOKEN_IPLUS_UNAIRE, ANIME_TOKEN_IMOINS_UNAIRE, ANIME_TOKEN_RPLUS_UNAIRE, ANIME_TOKEN_RMOINS_UNAIRE))

#define UNARY_POSTFIX_OPERATOR_HUH(token_type) (int_member_huh((token_type), ANIME_TOKEN_INC, ANIME_TOKEN_DEC))

#define UNARY_OUTFIX_OPERATOR_HUH__OPEN(token_type) (int_member_huh((token_type), ANIME_TOKEN_OPENPAR, ANIME_TOKEN_OPENBRACKET))

#define UNARY_OUTFIX_OPERATOR_HUH__CLOSE(token_type) (int_member_huh((token_type), ANIME_TOKEN_CLOSEPAR, ANIME_TOKEN_CLOSEBRACKET))

#define UNARY_OUTFIX_OPERATOR__CLOSE_GET_MATCHING_OPEN(token_type) (ANIME_TOKEN_CLOSEBRACKET == token_type ? ANIME_TOKEN_OPENBRACKET : ANIME_TOKEN_CLOSEPAR == token_type ? ANIME_TOKEN_OPENPAR : -1)

#define BINARY_OPERATOR_HUH(token_type) (int_member_huh((token_type), ANIME_TOKEN_AFFECTATION, ANIME_TOKEN_AFFECTATION_SIMPLE, ANIME_TOKEN_AFFECTATION_IADD, ANIME_TOKEN_AFFECTATION_RADD, ANIME_TOKEN_AFFECTATION_ISUB, ANIME_TOKEN_AFFECTATION_RSUB, ANIME_TOKEN_AFFECTATION_IMULT, ANIME_TOKEN_AFFECTATION_RMULT, ANIME_TOKEN_AFFECTATION_IDIV, ANIME_TOKEN_AFFECTATION_RDIV, ANIME_TOKEN_AFFECTATION_IMOD, ANIME_TOKEN_AFFECTATION_L_AND, ANIME_TOKEN_AFFECTATION_L_OR, ANIME_TOKEN_AFFECTATION_L_XOR, ANIME_TOKEN_AFFECTATION_B_AND, ANIME_TOKEN_AFFECTATION_B_OR, ANIME_TOKEN_AFFECTATION_B_XOR, ANIME_TOKEN_AFFECTATION_B_RSHIFT, ANIME_TOKEN_AFFECTATION_B_LSHIFT, ANIME_TOKEN_LOGICAL_OR, ANIME_TOKEN_LOGICAL_AND, ANIME_TOKEN_LOGICAL_XOR, ANIME_TOKEN_BITWISE_OR, ANIME_TOKEN_BITWISE_AND, ANIME_TOKEN_BITWISE_XOR, ANIME_TOKEN_BITWISE_SHIFT_LEFT, ANIME_TOKEN_BITWISE_SHIFT_RIGHT, ANIME_TOKEN_EQUAL, ANIME_TOKEN_DIFF, ANIME_TOKEN_INF, ANIME_TOKEN_SUP, ANIME_TOKEN_INFEQ, ANIME_TOKEN_SUPEQ, ANIME_TOKEN_IPLUS_BINAIRE, ANIME_TOKEN_RPLUS_BINAIRE, ANIME_TOKEN_IMOINS_BINAIRE, ANIME_TOKEN_RMOINS_BINAIRE, ANIME_TOKEN_IMULT, ANIME_TOKEN_RMULT, ANIME_TOKEN_IDIV, ANIME_TOKEN_RDIV, ANIME_TOKEN_IMOD, ANIME_TOKEN_POINT, ANIME_TOKEN_FLECHE))

#define UNARY_AND_BINARY_OPERATOR_HUH(token_type) (int_member_huh((token_type), ANIME_TOKEN_IPLUS, ANIME_TOKEN_RPLUS, ANIME_TOKEN_IMINUS, ANIME_TOKEN_RMINUS))

#if 1
#define CONVERT_TO_UNARY_TYPE(token_type) (				\
									ANIME_TOKEN_IPLUS == (token_type) ? ANIME_TOKEN_IPLUS_UNAIRE : \
									ANIME_TOKEN_RPLUS == (token_type) ? ANIME_TOKEN_RPLUS_UNAIRE : \
									ANIME_TOKEN_IMINUS == (token_type) ? ANIME_TOKEN_IMOINS_UNAIRE : \
									ANIME_TOKEN_RMINUS == (token_type) ? ANIME_TOKEN_RMOINS_UNAIRE : \
									-1)

#define CONVERT_TO_BINARY_TYPE(token_type) (				\
									ANIME_TOKEN_IPLUS  == (token_type) ? ANIME_TOKEN_IPLUS_BINAIRE : \
									ANIME_TOKEN_RPLUS  == (token_type) ? ANIME_TOKEN_RPLUS_BINAIRE : \
									ANIME_TOKEN_IMINUS == (token_type) ? ANIME_TOKEN_IMOINS_BINAIRE : \
									ANIME_TOKEN_RMINUS == (token_type) ? ANIME_TOKEN_RMOINS_BINAIRE : \
									-1)
#endif


#endif /* ANIME_TOKEN_TYPE_H */

