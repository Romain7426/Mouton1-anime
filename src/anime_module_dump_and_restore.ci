
static void anime__endianness_byte_swap(anime_t * this) { 
  // TODO: Changer toutes ces macros en fonctions afin d’automatiser le processus. 
  //       Car, avec des macros, on peut pas sélectionner sur SIZEOF. 
  //       Donc, si on change la taille de int_lexeme_t ou d’un champ, alors il faut changer le code… 
  assert(sizeof(int_anime_error_t ) == sizeof(int16_t)); 
  assert(sizeof(int_anime_string_t) == sizeof(int16_t)); 
  assert(sizeof(int_lexeme_t      ) == sizeof(int16_t)); 
  assert(sizeof(int_lexeme_value_t) == sizeof(int16_t)); 

#define ENDIANNESS__SWAP__INT_LEXEME ENDIANNESS__SWAP__INT16 
  
  ENDIANNESS__SWAP__UINT16(this -> error_size); 
  ENDIANNESS__SWAP__UINT16(this -> string_stack_nb); 
  ENDIANNESS__SWAP__INT16(this -> copyright); 
  ENDIANNESS__SWAP__INT16(this -> filename); 
  ENDIANNESS__SWAP__INT16(this -> lexeme_value_stack__size); 
  ENDIANNESS__SWAP__INT16(this -> lexeme_value_stack__nb); 
  for (int_lexeme_t lexeme_i = 0; lexeme_i < this -> lexeme_stack__nb; lexeme_i++) { 
    ENDIANNESS__SWAP__INT16(this -> lexeme_stack__value); 
  }; 
  ENDIANNESS__SWAP__INT16(this -> lexeme_stack__size); 
  ENDIANNESS__SWAP__INT16(this -> lexeme_stack__nb); 
  
  
  
#define ENDIANNESS__SWAP__FLOAT_4(ident1,ident2,ident3,ident4) ENDIANNESS__SWAP__FLOAT(this -> ident1);	ENDIANNESS__SWAP__FLOAT(this -> ident2); ENDIANNESS__SWAP__FLOAT(this -> ident3); ENDIANNESS__SWAP__FLOAT(this -> ident4); 
  
  ENDIANNESS__SWAP__FLOAT_4(choc_longueur, choc_largeur, choc_hauteur, masse); 
  
  ENDIANNESS__SWAP__INT16(this -> vie); 

#define ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident0,__taille__) { for (int item_i = 0; item_i < (__taille__); item_i++) { ENDIANNESS__SWAP__INT16(this -> glue2(__prefix__,ident0)[item_i]); }; }; 
#define ENDIANNESS__SWAP__INT16__ARRAY_1(__prefix__,ident1,__taille__) ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident1,__taille__); 
#define ENDIANNESS__SWAP__INT16__ARRAY_2(__prefix__,ident1,ident2,__taille__) ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident2,__taille__); 
#define ENDIANNESS__SWAP__INT16__ARRAY_3(__prefix__,ident1,ident2,ident3,__taille__) ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident3,__taille__); 
#define ENDIANNESS__SWAP__INT16__ARRAY_4(__prefix__,ident1,ident2,ident3,ident4,__taille__) ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident3,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident4,__taille__); 
#define ENDIANNESS__SWAP__INT16__ARRAY_5(__prefix__,ident1,ident2,ident3,ident4,ident5,__taille__) ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident3,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident4,__taille__); ENDIANNESS__SWAP__INT16__ARRAY(__prefix__,ident5,__taille__); 

#define ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident0,__taille__) { for (int item_i = 0; item_i < (__taille__); item_i++) { ENDIANNESS__SWAP__FLOAT(this -> glue2(__prefix__,ident0)[item_i]); }; }; 
#define ENDIANNESS__SWAP__FLOAT__ARRAY_1(__prefix__,ident1,__taille__) ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident1,__taille__); 
#define ENDIANNESS__SWAP__FLOAT__ARRAY_2(__prefix__,ident1,ident2,__taille__) ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident2,__taille__); 
#define ENDIANNESS__SWAP__FLOAT__ARRAY_3(__prefix__,ident1,ident2,ident3,__taille__) ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident3,__taille__); 
#define ENDIANNESS__SWAP__FLOAT__ARRAY_4(__prefix__,ident1,ident2,ident3,ident4,__taille__) ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident3,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident4,__taille__); 
#define ENDIANNESS__SWAP__FLOAT__ARRAY_5(__prefix__,ident1,ident2,ident3,ident4,ident5,__taille__) ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident3,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident4,__taille__); ENDIANNESS__SWAP__FLOAT__ARRAY(__prefix__,ident5,__taille__); 


  ENDIANNESS__SWAP__INT16__ARRAY_5(actions_array_,nom,affichage,icone,gestionnaire_fichier,gestionnaire_proc,this -> actions_nb); 
  ENDIANNESS__SWAP__INT16__ARRAY_5(events_array_,nom,genere_code_fichier,genere_code_proc,traitement_code_fichier,traitement_code_proc,this -> events_nb); 
  ENDIANNESS__SWAP__INT16__ARRAY_2(membres_,nom,image,this -> membres_nb); 
  ENDIANNESS__SWAP__FLOAT__ARRAY_3(membres_,largeur,hauteur,angle_max_y,this -> membres_nb); 
  ENDIANNESS__SWAP__INT16__ARRAY_4(racines_,x,y,z,angle_y,this -> racines_nb); 

  // LEXEME_I 

#define ENDIANNESS__SWAP__INT_LEXEME_3(ident1,ident2,ident3) ENDIANNESS__SWAP__INT_LEXEME(this -> glue2(ident1,__lexeme_i)); ENDIANNESS__SWAP__INT_LEXEME(this -> glue2(ident2,__lexeme_i)); ENDIANNESS__SWAP__INT_LEXEME(this -> glue2(ident3,__lexeme_i)); 
#define ENDIANNESS__SWAP__INT_LEXEME_4(ident1,ident2,ident3,ident4) ENDIANNESS__SWAP__INT_LEXEME(this -> glue2(ident1,__lexeme_i)); ENDIANNESS__SWAP__INT_LEXEME(this -> glue2(ident2,__lexeme_i)); ENDIANNESS__SWAP__INT_LEXEME(this -> glue2(ident3,__lexeme_i)); ENDIANNESS__SWAP__INT_LEXEME(this -> glue2(ident4,__lexeme_i)); 
  
  ENDIANNESS__SWAP__INT_LEXEME_4(choc_longueur,choc_largeur,choc_hauteur,masse);
  ENDIANNESS__SWAP__INT_LEXEME_3(vie,invincible,hostile);   
  
#define ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident0,__taille__) { for (int item_i = 0; item_i < (__taille__); item_i++) { ENDIANNESS__SWAP__INT_LEXEME(this -> glue3(__prefix__,ident0,__lexeme_i)[item_i]); }; }; 
#define ENDIANNESS__SWAP__INT_LEXEME__ARRAY_1(__prefix__,ident1,__taille__) ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident1,__taille__); 
#define ENDIANNESS__SWAP__INT_LEXEME__ARRAY_2(__prefix__,ident1,ident2,__taille__) ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident2,__taille__); 
#define ENDIANNESS__SWAP__INT_LEXEME__ARRAY_3(__prefix__,ident1,ident2,ident3,__taille__) ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident3,__taille__); 
#define ENDIANNESS__SWAP__INT_LEXEME__ARRAY_4(__prefix__,ident1,ident2,ident3,ident4,__taille__) ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident3,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident4,__taille__); 
#define ENDIANNESS__SWAP__INT_LEXEME__ARRAY_5(__prefix__,ident1,ident2,ident3,ident4,ident5,__taille__) ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident3,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident4,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident5,__taille__); 
#define ENDIANNESS__SWAP__INT_LEXEME__ARRAY_6(__prefix__,ident1,ident2,ident3,ident4,ident5,ident6,__taille__) ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident1,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident2,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident3,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident4,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident5,__taille__); ENDIANNESS__SWAP__INT_LEXEME__ARRAY(__prefix__,ident6,__taille__); 

  ENDIANNESS__SWAP__INT_LEXEME__ARRAY_5(actions_array_,nom,affichage,icone,gestionnaire_fichier,gestionnaire_proc,this -> actions_nb); 
  ENDIANNESS__SWAP__INT_LEXEME__ARRAY_6(events_array_,nom,genere_type,genere_code_fichier,genere_code_proc,traitement_code_fichier,traitement_code_proc,this -> events_nb); 
  ENDIANNESS__SWAP__INT_LEXEME__ARRAY_5(membres_,nom,image,largeur,hauteur,angle_max_y,this -> membres_nb); 
  ENDIANNESS__SWAP__INT_LEXEME__ARRAY_5(racines_,qui,x,y,z,angle_y,this -> racines_nb); 


}; 


int_anime_error_t anime__dump_to_fd(const anime_t * this, const int stddata_out_d) { 
  if (isatty(stddata_out_d)) return ANIME__DUMP__DUMPING_TO_TTY; 
  char buffer[ANIME_BYTESIZE];
  int_anime_error_t error_id; 
  int16_t actual_bytesize; 
  error_id = anime__dump_to_buffer(this, buffer, sizeof(buffer), &actual_bytesize); 
  if (0 > error_id) return error_id; 
  write(stddata_out_d, buffer, actual_bytesize); 
  return error_id; 
}; 
  

int_anime_error_t anime__dump_to_buffer(const anime_t * this, char * buffer, const int16_t buffer_bytesize, int16_t * used_bytesize_r) { 
  if (sizeof(anime_t) > (size_t) buffer_bytesize) return ANIME__DUMP__BUFFER_TOO_SMALL; 
  
  bcopy(/*src*/this, /*dst*/buffer, /*len*/sizeof(*this)); 
  
  anime_t * dump = (anime_t *) buffer; 
  
  if (NULL != used_bytesize_r) *used_bytesize_r = sizeof(*dump); 
  
  if (ANIME__ENDIANNESS_LITTLE == dump -> endianness_flag) return ANIME__OK; 
  if (ANIME__ENDIANNESS_BIG    == dump -> endianness_flag) return ANIME__OK; 
  if (ANIME__ENDIANNESS_NATIVE == dump -> endianness_flag) { 
#ifdef ENDIANNESS__NATIVE_IS_LITTLE 
    dump -> endianness_flag = ANIME__ENDIANNESS_LITTLE;
#elif defined ENDIANNESS__NATIVE_IS_BIG 
    dump -> endianness_flag = ANIME__ENDIANNESS_BIG;
#else 
    return ANIME__DUMP__ENDIANNESS_UNKNOWN; 
#endif 
    return ANIME__OK; 
  }; 
  
  return ANIME__DUMP__ENDIANNESS_UNKNOWN; 
  
  assert(false); 
}; 



int_anime_error_t anime__restore_from_fd(anime_t * this, const int stddata_in_d) { 
  char buffer[sizeof(anime_t)];
  int_anime_error_t error_id; 
  
  if (isatty(stddata_in_d)) return ANIME__RESTORE__READING_FROM_TTY; 
  
  int16_t total_read = 0; 
  for (;;) { 
    const ssize_t read_nb = read(stddata_in_d, buffer + total_read, sizeof(buffer) - total_read); 
    if (0  > read_nb) return ANIME__RESTORE__ERROR_WHILE_READING_INPUT; 
    if (0 == read_nb) break; 
    total_read += read_nb; 
    if ((size_t) total_read >= sizeof(anime_t)) break; 
  }; 
  
  if ((size_t) total_read < sizeof(anime_t)) return ANIME__RESTORE__INPUT_TOO_SMALL; 
  
  error_id = anime__restore_from_buffer(this, buffer, total_read, NULL); 
  
  return error_id;   
}; 

int_anime_error_t anime__restore_from_buffer(anime_t * this, const char * buffer, const int16_t buffer_bytesize, int16_t * used_bytesize_r) { 
  if (sizeof(anime_t) > (size_t) buffer_bytesize) return ANIME__RESTORE__BUFFER_TOO_SMALL; 
  
  bcopy(/*src*/buffer, /*dst*/this, /*len*/sizeof(*this)); 
  
  if (NULL != used_bytesize_r) *used_bytesize_r = sizeof(*this); 
  
  // FRA: RL: D’abord, quelques vérifications. 
  { 
    uint32_t this_bytesize = 0; 
    for (;;) { 
      if (ANIME__ENDIANNESS_LITTLE == this -> endianness_flag) { 
	this_bytesize = ENDIANNESS__LITTLE_TO_NATIVE__UINT32(this -> this_bytesize); break; };
      if (ANIME__ENDIANNESS_BIG == this -> endianness_flag) {
	this_bytesize = ENDIANNESS__BIG_TO_NATIVE__UINT32(this -> this_bytesize); break; };
      this_bytesize = this -> this_bytesize; 
    };
    assert((size_t)this_bytesize == sizeof(*this)); 
    
    uint8_t this_typename_bytesize = 0; 
    for (;;) { 
      if (ANIME__ENDIANNESS_LITTLE == this -> endianness_flag) { 
	this_typename_bytesize = ENDIANNESS__LITTLE_TO_NATIVE__UINT8(this -> this_typename_bytesize); break; }; 
      if (ANIME__ENDIANNESS_LITTLE == this -> endianness_flag) { 
	this_typename_bytesize = ENDIANNESS__BIG_TO_NATIVE__UINT8(this -> this_typename_bytesize); break; }; 
      this_typename_bytesize = this -> this_typename_bytesize;
    };
    assert((size_t)this_typename_bytesize == sizeof(this -> this_typename)); 
    
    assert(0 == strcmp("anime_t",this -> this_typename)); 
    assert(ANIME_VERSION_MAJOR    == this -> version_major); 
    assert(ANIME_VERSION_MINOR    == this -> version_minor); 
    assert(ANIME_VERSION_REVISION == this -> version_revision); 
  }; 
  
  // RL: Maintenant, nous devons convertir toutes les données depuis le format enregi
  if (ANIME__ENDIANNESS_LITTLE == this -> endianness_flag) { 
#ifndef ENDIANNESS__NATIVE_IS_LITTLE 
    anime__endianness_byte_swap(dump); 
#endif 
    this -> endianness_flag = ANIME__ENDIANNESS_NATIVE; 
    return ANIME__OK; 
  };
  if (ANIME__ENDIANNESS_BIG == this -> endianness_flag) { 
#ifndef ENDIANNESS__NATIVE_IS_BIG 
    anime__endianness_byte_swap(this); 
#endif 
    this -> endianness_flag = ANIME__ENDIANNESS_NATIVE; 
    return ANIME__OK; 
  }; 
  if (ANIME__ENDIANNESS_NATIVE == this -> endianness_flag) { 
    return ANIME__OK; 
  }; 
  if (ANIME__ENDIANNESS_UNSPECIFIED == this -> endianness_flag) { 
    // FRA: RL: Pas sûr de ce qui devrait être fait. Donc on ne fait rien. 
    return ANIME__RESTORE__ENDIANNESS_IS_UNSPECIFIED; 
  }; 
  
  assert(false); 
}; 

